var documenterSearchIndex = {"docs":
[{"location":"#ImplicitGraphs","page":"ImplicitGraphs","title":"ImplicitGraphs","text":"","category":"section"},{"location":"","page":"ImplicitGraphs","title":"ImplicitGraphs","text":"An ImplicitGraph is a graph in which the vertices and edges are implicitly defined by two functions: one that tests for vertex membership and one that returns a list of the (out) neighbors of a vertex. ","category":"page"},{"location":"","page":"ImplicitGraphs","title":"ImplicitGraphs","text":"The vertex set of an ImplicitGraph may be finite or (implicitly) infinite. The (out) degrees, however, must be finite.","category":"page"},{"location":"#Creating-Graphs","page":"ImplicitGraphs","title":"Creating Graphs","text":"","category":"section"},{"location":"","page":"ImplicitGraphs","title":"ImplicitGraphs","text":"An ImplicitGraph is defined as follows:","category":"page"},{"location":"","page":"ImplicitGraphs","title":"ImplicitGraphs","text":"ImplicitGraph{T}(has_vertex, out_neighbors)","category":"page"},{"location":"","page":"ImplicitGraphs","title":"ImplicitGraphs","text":"where ","category":"page"},{"location":"","page":"ImplicitGraphs","title":"ImplicitGraphs","text":"T is the data type of the vertices.\nhas_vertex(v::T)::Bool is a function that takes objects of type T as input and returns true if v is a vertex of the graph.\nout_neighbors(v::T)::Vector{T} is a function that takes objects of type T as input and returns a list of the (out) neighbors of v.","category":"page"},{"location":"","page":"ImplicitGraphs","title":"ImplicitGraphs","text":"For example, the following creates an (essentially) infinite path whose vertices are integers (see the iPath function):","category":"page"},{"location":"","page":"ImplicitGraphs","title":"ImplicitGraphs","text":"yes(v::Int)::Bool = true \nN(v::Int)::Vector{Int} = [v-1, v+1]\nG = ImplicitGraph{Int}(yes, N)","category":"page"},{"location":"","page":"ImplicitGraphs","title":"ImplicitGraphs","text":"The yes function always returns true for any Int. The N function returns the two neighbors of a vertex v. (For a truly infinite path, use BigInt in place of Int.)","category":"page"},{"location":"","page":"ImplicitGraphs","title":"ImplicitGraphs","text":"Note that if v is an element of its own neighbor set, that represents a loop at vertex v.","category":"page"},{"location":"#Undirected-and-directed-graphs","page":"ImplicitGraphs","title":"Undirected and directed graphs","text":"","category":"section"},{"location":"","page":"ImplicitGraphs","title":"ImplicitGraphs","text":"The user-supplied out_neighbors function can be used to create both undirected and directed graphs. If an undirected graph is intended, be sure that if {v,w} is an edge of the graph, then w will be in the list returned by out_neighbors(v) and v will be in the list returned by out_neighbors(w).","category":"page"},{"location":"","page":"ImplicitGraphs","title":"ImplicitGraphs","text":"To create an infinite directed path, the earlier example can be modified like this:","category":"page"},{"location":"","page":"ImplicitGraphs","title":"ImplicitGraphs","text":"yes(v::Int)::Bool = true \nN(v::Int)::Vector{Int} = [v+1]\nG = ImplicitGraph{Int}(yes, N)","category":"page"},{"location":"#Predefined-Graphs","page":"ImplicitGraphs","title":"Predefined Graphs","text":"","category":"section"},{"location":"","page":"ImplicitGraphs","title":"ImplicitGraphs","text":"We provide a few basic graphs that can be created using the following methods:","category":"page"},{"location":"","page":"ImplicitGraphs","title":"ImplicitGraphs","text":"iCycle(n::Int) creates an undirected cycle with vertex set {1,2,...,n};  iCycle(n,false) creates a directed n-cycle.\niPath() creates an (essentially) infinite undirected path whose vertex set contains all integers  (objects of type Int); iPath(false) creates a one-way infinite path ⋯ → -2 → -1 → 0 → 1 → 2 → ⋯.\niGrid() creates an (essentially) infinite grid whose vertices are ordered pairs of integers (objects of type Int).\niCube(d::Int) creates a d-dimensional cube graph. The vertices are all d-long strings of 0s and 1s. Two vertices are adjacent iff they differ in exactly one bit.\niKnight() creates the Knight's move graph on an (essentially) infinite chessboard. The vertices are pairs of integers (objects of type Int).\niShift(alphabet, n::Int) creates the shift digraph whose vertices are n-tuples of elements of alphabet.","category":"page"},{"location":"#Inspection","page":"ImplicitGraphs","title":"Inspection","text":"","category":"section"},{"location":"","page":"ImplicitGraphs","title":"ImplicitGraphs","text":"To test if v is a vertex of an ImplicitGraph G, use has(G). Note that the data type of v must match the element type of G. (The function eltype returns the data type of the vertices of the ImplicitGraph.)\nTo test if {v,w} is an edge of G use G[v,w] or has(G,v,w). Note that v and w must both be vertices of G or an error is thrown.\nTo get a list of the (out) neighbors of a vertex v, use G[v].\nTo get the degree of a vertex in a graph, use deg(G,v).","category":"page"},{"location":"","page":"ImplicitGraphs","title":"ImplicitGraphs","text":"julia> G = iGrid()\nImplicitGraph{Tuple{Int64,Int64}}\n\njulia> has_vertex(G,(1,2))\ntrue\n\njulia> G[(1,2)]\n4-element Array{Tuple{Int64,Int64},1}:\n (1, 1)\n (1, 3)\n (0, 2)\n (2, 2)\n\njulia> G[(1,2),(1,3)]\ntrue\n\njulia> deg(G,(5,0))\n4","category":"page"},{"location":"#Path-Finding","page":"ImplicitGraphs","title":"Path Finding","text":"","category":"section"},{"location":"#Shortest-path","page":"ImplicitGraphs","title":"Shortest path","text":"","category":"section"},{"location":"","page":"ImplicitGraphs","title":"ImplicitGraphs","text":"The function find_path finds a shortest path between vertices of a graph. This function may run without returning if the graph is infinite and disconnected.","category":"page"},{"location":"","page":"ImplicitGraphs","title":"ImplicitGraphs","text":"julia> G = iGrid()\nImplicitGraph{Tuple{Int64, Int64}}\n\njulia> find_path(G, (0, 0), (3, 5))\n9-element Array{Tuple{Int64, Int64}, 1}:\n (0, 0)\n (0, 1)\n (0, 2)\n (0, 3)\n (0, 4)\n (0, 5)\n (1, 5)\n (2, 5)\n (3, 5)","category":"page"},{"location":"","page":"ImplicitGraphs","title":"ImplicitGraphs","text":"The function dist returns the length of a shortest path between vertices in the graph.","category":"page"},{"location":"","page":"ImplicitGraphs","title":"ImplicitGraphs","text":"julia> dist(G, (0, 0), (3, 5))\n8","category":"page"},{"location":"","page":"ImplicitGraphs","title":"ImplicitGraphs","text":"For large undirected graphs, you may find that find_path_undirected runs faster. It uses bidirectional search to reduce memory usage and runtime. It does not support directed graphs, however.","category":"page"},{"location":"#Option:-abstract-target-vertices","page":"ImplicitGraphs","title":"Option: abstract target vertices","text":"","category":"section"},{"location":"","page":"ImplicitGraphs","title":"ImplicitGraphs","text":"Optionally, instead of a single target vertex whose type is the same as other vertices of the ImplicitGraph, we can call find_path with this signature:","category":"page"},{"location":"","page":"ImplicitGraphs","title":"ImplicitGraphs","text":"find_path(G::ImplicitGraph{T}, s::T, is_target::Function) where {T}","category":"page"},{"location":"","page":"ImplicitGraphs","title":"ImplicitGraphs","text":"The function is_target is expected to take a vertex of G as its only argument and return a Bool which is true if the vertex is a target. In this way, we can search for a path from the source vertex to one of many target vertices, or a vertex with a specified property.","category":"page"},{"location":"#Option:-cutoff-depth","page":"ImplicitGraphs","title":"Option: cutoff depth","text":"","category":"section"},{"location":"","page":"ImplicitGraphs","title":"ImplicitGraphs","text":"Path finding can consume an amout of memory that is exponential in the length of the path, which can crash Julia. To avoid this, we can call find_path with this signature:","category":"page"},{"location":"","page":"ImplicitGraphs","title":"ImplicitGraphs","text":"find_path(G::ImplicitGraph{T}, s::T, t::T, cutoff_depth::Int=0) where {T}","category":"page"},{"location":"","page":"ImplicitGraphs","title":"ImplicitGraphs","text":"Paths with length at most cutoff_depth will be found, but attempting to find a longer path results in an empty output (as if the path did not exist):","category":"page"},{"location":"","page":"ImplicitGraphs","title":"ImplicitGraphs","text":"julia> G = iGrid()\nImplicitGraph{Tuple{Int64,Int64}}\n\njulia> find_path(G, (0, 0), (3, 5), 8)\n9-element Array{Tuple{Int64 ,Int64}, 1}:\n (0, 0)\n (0, 1)\n (0, 2)\n (0, 3)\n (0, 4)\n (0, 5)\n (1, 5)\n (2, 5)\n (3, 5)\n\njulia> IG.find_path(G, (0, 0), (3, 5), 7)\nTuple{Int64, Int64}[]","category":"page"},{"location":"","page":"ImplicitGraphs","title":"ImplicitGraphs","text":"Note: Setting cutoff_depth to 0 allows a search for paths of unlimited length; only","category":"page"},{"location":"","page":"ImplicitGraphs","title":"ImplicitGraphs","text":"positive values limit the length. ","category":"page"},{"location":"#Guided-path-finding","page":"ImplicitGraphs","title":"Guided path finding","text":"","category":"section"},{"location":"","page":"ImplicitGraphs","title":"ImplicitGraphs","text":"The function guided_path_finder employs a score function to try to find a  path between vertices. It may be faster than find_path, but might not give a shortest path.","category":"page"},{"location":"","page":"ImplicitGraphs","title":"ImplicitGraphs","text":"This function is called as follows: guided_path_finder(G,s,t,score=sc, depth=d, verbose=0) where","category":"page"},{"location":"","page":"ImplicitGraphs","title":"ImplicitGraphs","text":"G is an ImplicitGraph,\ns is the starting vertex of the desired path,\nt is the ending vertex of the desired path,\nsc is a score function that mapping vertices to integers and should get smaller as vertices get closer to t (and should minimize at t), \nd controls amount of look ahead (default is 1), and \nverbose sets how often to print progess information (or 0 for no diagnostics).","category":"page"},{"location":"","page":"ImplicitGraphs","title":"ImplicitGraphs","text":"julia> G = iKnight();\n\njulia> s = (9,9); t = (0,0);\n\njulia> sc(v) = sum(abs.(v));  # score of (a,b) is |a| + |b|\n\njulia> guided_path_finder(G,s,t,score=sc,depth=1)\n9-element Vector{Tuple{Int64, Int64}}:\n (9, 9)\n (8, 7)\n (7, 5)\n (6, 3)\n (5, 1)\n (3, 0)\n (1, -1)\n (-1, -2)\n (0, 0)\n\n# With better look-ahead we find a shorter path\n\njulia> guided_path_finder(G,s,t,score=sc,depth=3)\n7-element Vector{Tuple{Int64, Int64}}:\n (9, 9)\n (8, 7)\n (7, 5)\n (6, 3)\n (4, 2)\n (2, 1)\n (0, 0)","category":"page"},{"location":"","page":"ImplicitGraphs","title":"ImplicitGraphs","text":"Greater depth can find a shorter path, but that comes at a cost:","category":"page"},{"location":"","page":"ImplicitGraphs","title":"ImplicitGraphs","text":"julia> using BenchmarkTools\n\njulia> @btime guided_path_finder(G,s,t,score=sc,depth=1);\n  52.361 μs (1308 allocations: 81.05 KiB)\n\njulia> @btime guided_path_finder(G,s,t,score=sc,depth=3);\n  407.546 μs (8691 allocations: 696.47 KiB)","category":"page"},{"location":"#Extras","page":"ImplicitGraphs","title":"Extras","text":"","category":"section"},{"location":"","page":"ImplicitGraphs","title":"ImplicitGraphs","text":"The extras directory contains additional code and examples that may be  useful in conjunction with the ImplicitGraph type. See the README  in that directory.","category":"page"}]
}
